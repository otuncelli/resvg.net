using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Text;
using System.Text.RegularExpressions;

namespace resvg.net.SourceGenerator
{
    [Generator]
    public class ResvgSourceGenerator : ISourceGenerator
    {
        private static readonly bool UseDelegates = false;
        private const string LibraryName = "resvg";
        private readonly Regex ParseSignatureRegex = new Regex(@"(\w+)\s(\w+)\((.*)\)", RegexOptions.Compiled);
        private readonly Regex RegexStringAttribute = new Regex(@"\bstring\b");
        private readonly IEnumerable<string> Archs = new[] { "X86", "X64", "Arm64" };

        public void Execute(GeneratorExecutionContext context)
        {
            string[] signatures =
            {
                "ResvgTransform resvg_transform_identity()",
                "void resvg_init_log()",
                "IntPtr resvg_options_create()",
                "void resvg_options_set_resources_dir(IntPtr opt, string path)",
                "void resvg_options_set_dpi(IntPtr opt, float dpi)",
                "void resvg_options_set_font_family(IntPtr opt, string family)",
                "void resvg_options_set_font_size(IntPtr opt, float size)",
                "void resvg_options_set_serif_family(IntPtr opt, string family)",
                "void resvg_options_set_sans_serif_family(IntPtr opt, string family)",
                "void resvg_options_set_cursive_family(IntPtr opt, string family)",
                "void resvg_options_set_fantasy_family(IntPtr opt, string family)",
                "void resvg_options_set_monospace_family(IntPtr opt, string family)",
                "void resvg_options_set_languages(IntPtr opt, string languages)",
                "void resvg_options_set_shape_rendering_mode(IntPtr opt, ShapeRenderingMode mode)",
                "void resvg_options_set_text_rendering_mode(IntPtr opt, TextRenderingMode mode)",
                "void resvg_options_set_image_rendering_mode(IntPtr opt, ImageRenderingMode mode)",
                "void resvg_options_load_font_data(IntPtr opt, IntPtr data, UIntPtr length)",
                "ResvgError resvg_options_load_font_file(IntPtr opt, string file_path)",
                "void resvg_options_load_system_fonts(IntPtr opt)",
                "void resvg_options_destroy(IntPtr opt)",
                "ResvgError resvg_parse_tree_from_file(string file_path, IntPtr opt, out IntPtr tree)",
                "ResvgError resvg_parse_tree_from_data(string data, UIntPtr length, IntPtr opt, out IntPtr tree)",
                "bool resvg_is_image_empty(IntPtr tree)",
                "ResvgSize resvg_get_image_size(IntPtr tree)",
                "ResvgRect resvg_get_image_viewbox(IntPtr tree)",
                "bool resvg_get_image_bbox(IntPtr tree, out ResvgRect bbox)",
                "bool resvg_node_exists(IntPtr tree, string id)",
                "bool resvg_get_node_transform(IntPtr tree, string id, out ResvgTransform transform)",
                "bool resvg_get_node_bbox(IntPtr tree, string id, out ResvgRect bbox)",
                "void resvg_tree_destroy(IntPtr tree)",
                "void resvg_render(IntPtr tree, ResvgTransform transform, uint width, uint height, IntPtr pixmap)",
                "bool resvg_render_node(IntPtr tree, string id, ResvgTransform transform, uint width, uint height, IntPtr pixmap)",
            };

            StringBuilder source = new StringBuilder(@"// <auto-generated/>
using System;
using System.Runtime.InteropServices;

namespace resvg.net
{
    internal static partial class NativeMethods
    {");

            foreach (string signature in signatures)
            {
                if (UseDelegates)
                {
                    WriteFunctionDelegates(source, signature);
                }
                else
                {
                    WritePinvokeMethods(source, signature);
                }
            }

            source.Append(@"
    }
}");
            string s = source.ToString();
            context.AddSource("NativeMethods.g.cs", s);

            if (UseDelegates)
            {
                source = new StringBuilder();
                WriteFunctionDelegates2(source);
                s = source.ToString();
                context.AddSource("NativeMethods.Delegates.g.cs", s);
            }
        }

        private void WritePinvokeMethods(StringBuilder source, string signature)
        {
            Match match = ParseSignatureRegex.Match(signature);
            string returnType = match.Groups[1].Value;
            string methodName = match.Groups[2].Value;
            string arguments = match.Groups[3].Value;
            string argumentsWithoutType = GetArgumentsWithoutType(arguments);
            string argumentsWithAttributes = RegexStringAttribute.Replace(arguments, "[MarshalAs(UnmanagedType.LPUTF8Str)] string");
            string returnPrefix = returnType == "void" ? String.Empty : "return ";

            source.Append($@"
        #region {methodName}

        private static partial class PlatformInvoke
        {{");
            foreach (string arch in Archs)
            {
                source.Append($@"
            [DllImport(""{LibraryName}_{arch}"", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Ansi, EntryPoint = ""{methodName}"")]");
                if (returnType == "bool")
                {
                    source.Append(@"
            [return: MarshalAs(UnmanagedType.I1)]");
                }
                source.Append($@"
            public static extern {returnType} {methodName}_{arch}({argumentsWithAttributes});");
            }
            source.Append(@"
        }");

            source.Append($@"

        public static {returnType} {methodName}({arguments})
        {{
            switch (RuntimeInformation.ProcessArchitecture)
            {{");
            foreach (string arch in Archs)
            {
                source.Append($@"
                case Architecture.{arch}:
                    {returnPrefix}PlatformInvoke.{methodName}_{arch}({argumentsWithoutType});");
                if (returnPrefix.Length == 0)
                {
                    source.Append(@"
                    break;");
                }
            }
            source.Append(@"
                default:
                    throw new PlatformNotSupportedException();");
            source.Append(@"
            }
        }

        #endregion
");
        }

        private void WriteFunctionDelegates(StringBuilder source, string signature)
        {
            Match match = ParseSignatureRegex.Match(signature);
            string returnType = match.Groups[1].Value;
            string methodName = match.Groups[2].Value;
            string arguments = match.Groups[3].Value;
            string argumentsWithoutType = GetArgumentsWithoutType(arguments);
            string argumentsWithAttributes = RegexStringAttribute.Replace(arguments, "[MarshalAs(UnmanagedType.LPUTF8Str)] string");
            string returnPrefix = returnType == "void" ? String.Empty : "return ";

            string delegateName = methodName + "_delegate";
            string fptrName = methodName + "_fptr";

            source.Append($@"
        #region {methodName}

        [UnmanagedFunctionPointer(CallingConvention.Cdecl, CharSet = CharSet.Ansi)]");
            if (returnType == "bool")
            {
                source.Append(@"
        [return: MarshalAs(UnmanagedType.I1)]");
            }

            source.Append($@"
        private delegate {returnType} {delegateName}({argumentsWithAttributes});

        private static {delegateName} {fptrName} =
            ({arguments}) =>
            {{
               {fptrName} =
                   GetDelegateForFunction<{delegateName}>(""{LibraryName}"", ""{methodName}"");
               {returnPrefix}{fptrName}({argumentsWithoutType});
            }};

        public static {returnType} {methodName}({arguments})
        {{
            {returnPrefix}{fptrName}({argumentsWithoutType});
        }}

        #endregion
");
        }

        private void WriteFunctionDelegates2(StringBuilder source)
        {
            source.Append(@"// <auto-generated/>
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Reflection;
using System.Runtime.InteropServices;

namespace resvg.net
{
    internal static partial class NativeMethods
    {
        private static readonly string Extension = GetExtension();

        private static readonly ConcurrentDictionary<string, IntPtr> LoadedLibraries = new ConcurrentDictionary<string, IntPtr>();

        private static string GetExtension()
        {
            if (PlatformConfiguration.IsWindows) return "".dll"";
            if (PlatformConfiguration.IsMac) return "".dylib"";
            return "".so"";
        }

        public static void FreeLibraries()
        {
            ICollection<string> keys = LoadedLibraries.Keys;
            foreach (string key in keys)
            {
                if (LoadedLibraries.TryRemove(key, out IntPtr lib))
                {
                    NativeLibrary.Free(lib);
                }
            }
        }

        private static TDelegate GetDelegateForFunction<TDelegate>(string libraryName, string procName) where TDelegate : Delegate
        {
            IntPtr lib = LoadedLibraries.GetOrAdd(libraryName, GetLibrary);
            IntPtr fptr = NativeLibrary.GetExport(lib, procName);
            return Marshal.GetDelegateForFunctionPointer<TDelegate>(fptr);
        }

        private static IntPtr GetLibrary(string libraryName)
        {
            string libraryPath = GetLibraryPath(libraryName);
            IntPtr handle = NativeLibrary.Load(libraryPath);
            if (handle == IntPtr.Zero)
            {
                throw new DllNotFoundException($""Unable to load library '{libraryName}'."");
            }
            return handle;
        }

        private static string GetLibraryPath(string libraryName)
        {
            string arch = PlatformConfiguration.Is64Bit
                ? PlatformConfiguration.IsArm ? ""arm64"" : ""x64""
                : PlatformConfiguration.IsArm ? ""arm"" : ""x86"";

            string libWithExt = libraryName;
            if (!libraryName.EndsWith(Extension, StringComparison.OrdinalIgnoreCase))
                libWithExt += Extension;

            // 1. try alongside managed assembly
            string path = Assembly.GetExecutingAssembly().Location;
            if (!string.IsNullOrEmpty(path))
            {
                path = Path.GetDirectoryName(path);
                if (CheckLibraryPath(path, arch, libWithExt, out string localLib))
                    return localLib;
            }

            // 2. try current directory
            if (CheckLibraryPath(Directory.GetCurrentDirectory(), arch, libWithExt, out string lib))
                return lib;

            // 3. try app domain
            try
            {
                if (AppDomain.CurrentDomain is AppDomain domain)
                {
                    // 3.1 RelativeSearchPath
                    if (CheckLibraryPath(domain.RelativeSearchPath, arch, libWithExt, out lib))
                        return lib;

                    // 3.2 BaseDirectory
                    if (CheckLibraryPath(domain.BaseDirectory, arch, libWithExt, out lib))
                        return lib;
                }
            }
            catch
            {
                // no-op as there may not be any domain or path
            }

            // 4. use PATH or default loading mechanism
            return libWithExt;
        }

        private static bool CheckLibraryPath(string root, string arch, string libWithExt, out string foundPath)
        {
            if (!string.IsNullOrEmpty(root))
            {
                // a. in specific platform sub dir
                if (!string.IsNullOrEmpty(PlatformConfiguration.LinuxFlavor))
                {
                    var muslLib = Path.Combine(root, PlatformConfiguration.LinuxFlavor + ""-"" + arch, libWithExt);
                    if (File.Exists(muslLib))
                    {
                        foundPath = muslLib;
                        return true;
                    }
                }

                // b. in generic platform sub dir
                string searchLib = Path.Combine(root, arch, libWithExt);
                if (File.Exists(searchLib))
                {
                    foundPath = searchLib;
                    return true;
                }

                searchLib = Path.Combine(root, Path.GetFileNameWithoutExtension(libWithExt) + ""_"" + arch + Extension);
                if (File.Exists(searchLib))
                {
                    foundPath = searchLib;
                    return true;
                }

                // c. in root
                searchLib = Path.Combine(root, libWithExt);
                if (File.Exists(searchLib))
                {
                    foundPath = searchLib;
                    return true;
                }
            }

            // d. nothing
            foundPath = null;
            return false;
        }

        private static class PlatformConfiguration
        {
            public static bool IsUnix { get; }

            public static bool IsWindows { get; }

            public static bool IsMac { get; }

            public static bool IsLinux { get; }

            public static bool IsArm { get; }

            public static bool Is64Bit { get; }

            static PlatformConfiguration()
            {
                IsMac = RuntimeInformation.IsOSPlatform(OSPlatform.OSX);
                IsLinux = RuntimeInformation.IsOSPlatform(OSPlatform.Linux);
                IsUnix = IsMac || IsLinux;
                IsWindows = RuntimeInformation.IsOSPlatform(OSPlatform.Windows);
                Architecture arch = RuntimeInformation.ProcessArchitecture;
                IsArm = arch == Architecture.Arm || arch == Architecture.Arm64;
                Is64Bit = Environment.Is64BitProcess;
            }

            private static string linuxFlavor;

            public static string LinuxFlavor
            {
                get
                {
                    if (!IsLinux)
                        return null;

                    if (!string.IsNullOrEmpty(linuxFlavor))
                        return linuxFlavor;

                    // we only check for musl/glibc right now
                    if (!IsGlibc)
                        return ""musl"";

                    return null;
                }
                set => linuxFlavor = value;
            }

            private static readonly Lazy<bool> isGlibcLazy = new Lazy<bool>(IsGlibcImplementation);

            public static bool IsGlibc => IsLinux && isGlibcLazy.Value;

            private static bool IsGlibcImplementation()
            {
                try
                {
                    gnu_get_libc_version();
                    return true;
                }
                catch (TypeLoadException)
                {
                    return false;
                }
            }

            [DllImport(""c"", ExactSpelling = true, CallingConvention = CallingConvention.Cdecl)]
            private static extern IntPtr gnu_get_libc_version();
        }
    }
}");
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            // No initialization required for this one
        }

        private static string GetArgumentsWithoutType(string args)
        {
            string[] arr0 = args.Split(',');
            StringBuilder argsWithoutType = new StringBuilder();
            if (arr0.Length > 0)
            {
                for (int i = 0; i < arr0.Length; i++)
                {
                    string arg = arr0[i].Trim();
                    if (arg.Length == 0)
                    {
                        continue;
                    }
                    string[] arr1 = arg.Split(' ');
                    switch (arr1[0])
                    {
                        case "out":
                        case "ref":
                        case "in":
                            argsWithoutType.Append(string.Join(" ", arr1[0], arr1[2]));
                            break;
                        default:
                            argsWithoutType.Append(arr1[1]);
                            break;
                    }
                    if (i != arr0.Length - 1)
                    {
                        argsWithoutType.Append(", ");
                    }
                }
            }
            return argsWithoutType.ToString();
        }
    }
}
