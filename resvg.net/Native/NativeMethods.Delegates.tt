<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="System.Runtime.InteropServices.RuntimeInformation" #>
<#@ assembly name="Microsoft.VisualBasic" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Runtime.InteropServices" #>
<#@ import namespace="Microsoft.VisualBasic.FileIO" #>
<#@ output extension=".g.cs" #>
<#
const string CsvPath = @"D:\workspace\resvg.net\resvg.net\Native\NativeMethods.csv";
const string Namespace = "resvg.net";
#>
// <auto-generated />
using System;
using System.Runtime.InteropServices;

namespace <#=Namespace#>
{
    internal static partial class NativeMethods
    {
<#
using TextFieldParser csv = new TextFieldParser(CsvPath);
csv.TextFieldType = FieldType.Delimited;
csv.SetDelimiters(",");
csv.ReadFields();
while (!csv.EndOfData) 
{
    string[] fields = csv.ReadFields();
    WriteDelegates(fields);
}
#>
    }
}

<#+
    public void WriteDelegates(string[] fields)
    {
        Match m = Regex.Match(fields[0], @"(\w+)\s(\w+)\((.*)\)");
        string returnType = m.Groups[1].Value.Trim();
        string methodName = m.Groups[2].Value.Trim();
        string args = m.Groups[3].Value.Trim();
        string argsWithoutType = GetArgsWithoutType(args);
        args = args.Replace(" string ", " [MarshalAs(UnmanagedType.LPUTF8Str)] string ");
        string dlgName = methodName + "_delegate";
        string fptrName = methodName + "_fptr";
        string returnPrefix = returnType == "void" ? String.Empty : "return ";
        string library = "resvg";
#>
        #region <#=methodName#>

        [UnmanagedFunctionPointer(CallingConvention.Cdecl, CharSet = CharSet.Ansi)]
<#+
            if (returnType == "bool") {
#>
        [return: MarshalAs(UnmanagedType.Bool)]
<#+
            }
#>
        private delegate <#=returnType#> <#=dlgName#>(<#=args#>);

        private static <#=dlgName#> <#=fptrName#> =
           (<#=StripAttributes(args)#>) =>
           {
               <#=fptrName#> =
                   GetDelegateForFunction<<#=dlgName#>>("<#=library#>", "<#=methodName#>");
               <#=returnPrefix#><#=fptrName#>(<#=argsWithoutType#>);
           };

        public static <#=returnType#> <#=methodName#>(<#=args#>)
        {
            <#=returnPrefix#><#=fptrName#>(<#=argsWithoutType#>);
        }

        #endregion

<#+
    } // WritePinvokeMethods
    private static string GetArgsWithoutType(string args)
    {
        args = StripAttributes(args);
        string[] tmpArray0 = args.Split(',');
        string argsWithoutType = "";
        if (tmpArray0.Length > 0)
        {
            for (int i = 0; i < tmpArray0.Length; i++)
            {
                string arg = tmpArray0[i].Trim();
                if (arg.Length == 0)
                {
                    continue;
                }
                string[] tmpArray1 = arg.Split(' ');
                switch(tmpArray1[0])
                {
                    case "out":
                    case "ref":
                    case "in":
                        argsWithoutType += tmpArray1[0] + " " + tmpArray1[2];
                        break;
                    default:
                        argsWithoutType += tmpArray1[1];
                        break;
                }
                if (i != tmpArray0.Length - 1)
                {
                    argsWithoutType += ", ";
                }
            }
        }
        return argsWithoutType;
    }

    private static string StripAttributes(string args)
    {
        return Regex.Replace(args, @"\[.*\]", String.Empty).Replace("  ", " ").Trim();
    }
#>